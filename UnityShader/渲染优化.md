##### 移动平台的特点

为了尽可能移除那些隐藏的表面，减少 overdraw (即 个像素被绘制多次，使用了基于瓦片的延迟渲染 (Tiled-based Deferred  Rendering, TBDR) 架构 把所有的渲染图像装入一个个瓦片 (tile) 中，再由硬件找到可见的片元，而只有这些可见片元才会执行片元着色器。另一些基于瓦片的架构 则会使用 early-Z 或相似的技术进行一个低精度的的深度检测， 来剔除那些不需要渲染的片元

##### 影响性能的因素

- CPU
  - 过多drawcall
  - 复杂的脚本/物理模拟
- GPU
  - 顶点处理
    - 过多的顶点
    - 过多的逐定点计算
  - 片元处理
    - 过多的片元
    - 过多的逐片元计算
- 带宽
  - 尺寸过大未压缩的纹理
  - 分辨率过高的帧缓存

##### 减少draw call 数目

###### 批处理batching

每次调用drawcall时尽可能处理多个物体。

使用**同一个材质**的物体可以一起处理

动态批处理：满足条件的模型和材质才可以被动态批处理 多pass的shader会终端批处理

静态批处理：在运行开始阶段合并到一个新的网格结构中 那么不可以在运行时被移动 只需要一次合并操作

会占用更多的内存

###### 共享材质

如果两个材质只有纹理不同可以把纹理合并到更大的纹理中（**图集atlas**）

但有时， 除了纹理不同外， 不同的物体在材质上还有一些微小的参数变化， 例如， 颜色不同 某些浮点屈性不同。一种常用的方法就是使用网格的顶点数据（最常见的就是顶点颜色数据）来存储这些参数。

对 VBO 中的数据进行控制， 从而达到不同效果的目的。 一个例子是， 森林场泉中所有的树使用了同一种材质， 我们希望它们可以通过批处理 来减少 draw call, 但不同树的颜色可能不同。 这时，我们可以利用网格的顶点的颜色数据来调整

##### 减少需要处理的顶点数目

###### 优化几何体

尽可能减少中模型中三角面片的数目

GPU有时需要把顶点**拆分**，为了**分离纹理坐标**和**产生平滑的边界**

对于立方体 它的面之间虽然使用了相同的顶点 ，但在不同面顶点的纹理坐标可能并不相同

而平滑边界也是类似的，不同的是，此时顶点可能会对应多个法线信息或切线信息。 这通常是因为我们要决定边是硬边 hard edge 还是 平滑边 smooth edge

###### LOD技术

物体离摄像机很远时， 模型上的很多细节是无法被察觉到的。 因此，LOD允许当对象逐渐远离摄像机时， 减少模型上的面片数凰， 从而提高性能。

在  Unity中，我们可以使用LOO Group组件来为 个物体构建个LOD。我们需要为同 个 对象准备多个包含不同细节程度的模型， 然后把它们赋给LOD Group组件中的不同等 级， Unity 就会自动判断当前位置上需要使用哪个等级的模型。

###### 遮挡剔除 Occlusion culling



##### 减少需要处理的片元数目

这部分优化的重点在于减少overdraw。

###### 控制绘制顺序

由于深度测试的存在， 如果我们可以保证物体都是从前往后绘制的， 那么就可以很大程度上减少overdraw。 这是因为， 在后面绘制的物体无法通过深度测试， 因此就不会再进行后面的渲染处理

在Unity中， 那些渲染队列数目小于2500 如"Background" "Geometry"和"AlphaTest") 的对象都被认为是不透明(opaque)的物体， 这些物体总体上是从前往后绘制的， 而使用其他的 队列（如"Transparent" "Overlay"等）的物体， 则是从后往前绘制的。 这意味着， 我们可以尽可 能地把物体的队列设置为不透明物体的渲染队列， 而尽量避免使用半透明队列。

###### 警惕透明物体

对于半透明对象来说， 由于它们没有开启深度写入，因此，如果要得到正确的渲染效果，必须从后往前渲染。 这意味着，半透明物体几乎一定会造成 overdraw。 如果不注意这一点， 在一些机器上可能会造成严重的性能下降。 例如，对于 GUI 对象来说，它们大多被设置成了半透明，如果屏轴中 GUI 占据的比例太多，而主摄像机又没有进行调整而是投影整个屏幕，那么 GUI 就会造成大量 overdraw。

上述 GUI 的这种情况，我们可以尽量减少窗口中 GUI 所占的面积。 如果实在无能为力， 我们可以把 GUI 的绘制和三维场景的绘制交给不同的摄像机，而其中负责三维场景的摄像机的视 角范围尽量不要和 GUI 的相互重叠

移动平台上，透明度测试也会影响游戏性能。 虽然透明度测试没有关闭深度写入，但由千 它的实现使用了 discard 或 clip 操作， 而这些操作会导致一些硬件的优化策略失效。 例如，我们之前讲过基于瓦片的延迟渲染技术，为了减少 overdraw 它会在调用片元若色器前 就判断哪些瓦片被真正渲染的。但是，由于透明度测试在片元着色器中使用了 discard 函数改变了 片元是否会被渲染的结果，因此，GPU 就无法使用上述的优化策略了。 也就是说，只要在执行了所有的片元着色器后，GPU 才知道哪些片元会被真正渲染到屏幕上，这样， 原先那些可以减少 overdraw 的优化就都无效了。 这种时候，使用透明度混合的性能往往比使用透明度测试更好

###### 减少实时光照和阴影

如果场景中包含了过多的点光源，并且使用 了多个 Pass 的 Shader, 那么很有可能会造成性能下降。 例如， 一个场景里如果包含了 3 个逐像素 的点光源， 而且使用了逐像素的 Shader, 那么很有可能将 draw call 数目 (CPU 的瓶颈） 提高 3 倍， 同时也会增加 overdraw (GPU 的瓶颈）。 这是因为， 对千逐像素的光源来说， 被这些光源照 亮的物体需要被再渲染一次。 更糟糕的是，无论是静态批处理还是动态批处理，对于这种额外的 处理逐像素光源的 Pass 都无法进行批处理， 也就是说，它们会中断批处理

很多成功的移动平台的游戏，它们的画面效果看起来好像包含了很多光源，这些游戏往往使用了烘焙技术， 把光照提前烘焙到一张光照纹理 `lightmap` 中，然后在运行时刻只需要根据纹理采样 得到光照结果即可。 另一个模拟光源的方法是使用 God Ray。 场景中很多小型光源的效果都是靠 这种方法模拟的。 它们一般并不是真的光源， 很多情况是通过透明纹理模拟得到的。 更多信息可 以参见本章的扩展阅读部分。 在移动平台上， 一个物体使用的逐像素光源数目应该小于1 (不包括平行光）。 如果一定要使用更多的实时光，可以选择用逐顶点光照来代替

开发者们把复杂的光照计算存储到一张查找纹理 (lookup texture, 也被称为查找表， lookup table, LUT 中。然后在运行时刻，我们只需要使用光源方向 、视角方向、 法线方向 等参数，对 LUT 采样得到光照结果即可。使用这样的查找纹理，不仅可以让我们使用更出色的光照模型，例如，更加复杂的 BRDF 模型，还可以利用查找纹理的大小来进一步优化性能，

##### 节省带宽

###### 减少纹理大小

需要注意的是，所有纹理的长宽比最好是正方形，而且长宽值最好是2的整数幕。这是因为有很多优化策略只有在这种时候才可以发挥最大效用

尽可能使用多级渐远纹理技术 (`mipmapping`) 和纹理压缩。在 Unity 中，我们可以通过纹理导 入面板来查看纹理的各个导入属性。通过把纹理类型设置为 Advanced , 就可以自定义许多选项，例如，是否生成Mipmap

纹理压缩同样可以节省带宽。但对于像 Android 这样的平台，有很多不同架构的 GPU, 纹理 压缩就变得有点复杂，因为不同的 GPU 架构有它自己的纹理压缩格式，例如， PowerVRAM 的 **PVRTC** 格式、 Tegra 的 **DXT** 格式、 Adreno 的 **ATC** 格式 。

过高的屏幕分辨率也是造成性能下降的原因之一，尤其是对于很多低端手机 除了分辨率高 其他硬件条件并不尽如人意，而这恰恰是游戏性能 瓶颈。过大的屏幕分辨率和糟糕 GPU 因此，我们可能需要对于特定机器进行分辨率的放缩。当然 这样可能会造成游戏效果的下降 但性能和画面之间永远是个需要权衡的话题

##### 减少计算复杂度

###### Shader的LOD技术

Shader LOD 技术可以控制使用的 Shader 等级。 它的原理是，只有 Shader LOD 小于某个设定的值，这 Shader 才会被使用 而使用那些超过设定值的 Shader 的物体将不会被渲染

```
SubShader{
	Tags {"RenderType"="Opaque"}
	LOD 200
}
```

在默认情况下，允 许的 LOD 等级是无限大的 这意味着，任何被当前显卡支持的 Shader 都可以被使用。但是，在 某些情况下我们可能需要去掉 些使用了复杂计算的 Shader 渲染

###### 代码优化

游戏需要计算的对象、顶点和像素的数目排序是对象数＜顶点数＜像素数。因此应该尽可能地把计算放在每个对象或逐顶点上

尽可能使用低精度的浮点值进行运算 最高精度的 float/highp 适用于存储诸如顶点坐标等变量 但它计算速度是最慢的，应该尽量避免在片元着色器中使用这种精度进行计算。而 half/mediump 适用于标量、纹理坐标等变蜇，它的计算速度大约是 float 的两倍

而fixed/lowp 适用于绝大多数颜色变蜇和归一化后的方向矢量，在进行一些对精度要求不高的计算时，我们应该尽量使用这种精度的变量。它的计算速度大约是 float 的4倍，但要避免对这些低精度变量进行频繁的 swizzle 操作（如 color.xwxw) 。

还需要注意的是，我们应当尽量避免在不同 精度之间的转换，这有可能会造成一 定的性能下降。

尽可能不要使用全屏的屏幕后处理效果。如果美术风格实在是需要使用类似 Bloom 、热扰动 这样的屏幕特效，我们应该尽量使用 fixed/lowp 进行低精度运算（纹理坐标除外，可以使用 half/mediump) 。那些高精度的运算可以使用 查找表 LUT) 或者转移到顶点着色器中进行处理。 除此之外，尽量把多个特效合并到 Shader 中。例如，我们可以把颜色校正和添加噪声等屏幕 特效在 Bloom 特效的最后一个 Pass 中进行合成

尽可能不要使用discard操作 这可能会影响硬件的某些优化