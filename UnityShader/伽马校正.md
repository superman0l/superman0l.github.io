伽马校正中的伽马一词来源伽马曲线。通常，伽马曲线的表达式如下： $L_{out} = L_{in}^{\gamma}$ 

 其中指数部分的发音就是伽马。最开始的时候，人们使用伽马曲线来对拍摄的图像进行伽马 编码 (gamma encoding) 。事情的起因可以从在真实环境中拍摄一张图片说起。摄像机的原理可 以简化为，把进入到镜头内的光线亮度编码成图像（例如一张 JEPG 中的像素。如果采集到的 亮度是 0, 像素就是0 亮度是1 , 像素就是1 亮度是 0.5, 像素就是 0.5 。如果我们只用 8 位空间来 存储像素的每个通道的话，这意味着 0~1 区间可以对应 256 种不同的亮度值。但是，后来人们发 现，人眼有一个有趣的特性，就是对光的灵敏度在不同亮度上是不一样的。在正常的光照条件下， 人眼对较暗区域的变化更加敏感

当1个屋子的光照由一盏灯增加到 两盏灯的时候，人眼对这种亮度变化的感知性要远远大于从 101 盏灯增加到 102 盏灯的变化，尽管从物理上来说这两种 变化基本是相同的。如果使用8位空间来存储每个通道的话，我们仍然把0.5 亮度编码成值为 0.5 的像素，那么暗部和亮部区域我们 都使用了 128 种颜色来表示，但实际上，对亮部区域使用这么多颜色是种存储浪费

摄影设备如果使用了8位空间来存储照片的话，会使用大约为 0.45 的编码伽马来对输入的亮 度进行编码，得到1张编码后的图像。因此，图像中 0.5 像素值对应的亮度其实并不是 0.5, 而大 约为 0.22 这是因为： $0.5≈   0.22^{45}$ 

当把图片放到显示器里显示时，我们应该对图像再进行再次解码操作，使得屏幕输出的亮度和捕捉到的亮度是符合线性的。这时 ，人们发现了 一个奇妙的巧合 ：CRT 显示器本身几乎已经自动做了这个 解码操作！这又从何说起呢？在早期， CRT (Cathode Ray Tube, 阴极射线管）几乎是唯一的显示 设备。这类设备的显示机制是，使用 电压轰击它屏幕上的图层，这个图层就可以发亮， 我们就可以看到图像了。但 CRT 显示器有个特性，它的输入电压和显示出来的亮度关系不是线性的，也就是说，如果我们把输入电压调高两倍，屏幕亮度并没有提高两倍。我们把显示器的这个伽马曲线称为显示伽马 (diplay gamma) 。非常巧合的是， CRT 的显示伽马值大约就是编码伽马的倒数。 CRT 显示器的这种特性，正好补偿了图像捕捉设备的伽马曲线

随微软联合爱普生、惠普提供了 sRGB 颜色空间标准，推荐显示器的显示伽马值为 2.2, 并配合 0.45 的编码伽马就可以保证最后伽马曲线之间可以相互抵消( $0.45*2.2≈1$ ) 。绝大多 数的摄像机、 PC 和打印机都使用了上述的 sRGB 标准。

对于输出来说，如果我们直接输出渲染结果而不进行任何处理，在经过显示器的显示伽马处理后 会导致图像**整体偏暗**，出现失真的状况.

伽马的存在还会对**混合**造成影响 。在伽马空间下，在绿色和红色的混合边界处出现了不正常的蓝色渐变。而正确的混合结果应该是从绿色到红色的渐变

实际上，渲染中非线性输入最有可能的来源就是**纹理**。为了充分利用存储空间，大多数图像 文件都进行了提前的校正，即已经使用了一个编码伽马对像素值编码。但这意味着它们是非线性 的，如果我们在 shader 中直接使用纹理采样值就会造成在非线性空间的计算，使得结果和真实世 界的结果不一致。我们在使用多级渐远纹理mipmaps 时也需要注意。如果纹理存储在非线性 空间中，那么在计算多级渐远纹理时就会在非线性空间里计算。由于多级渐远纹理的计算是种线 性计算－即采样的过程 需要对某个方形区域内的像素取平均值，这样就会得到错误的结果 正确的做法是，我们要把非线性的纹理转换到线性空间后再计算多级渐远纹理。

如上所说，伽马的存在使得我们很容易得到非线性空间下的渲染结果。在游戏渲染中，我们应该保证所有的输入都被转换到了线性空间下 并在线性空间下进行各种光照计算，最后在输出 前通过 1个编码伽马进行伽马校正后再输出到颜色缓冲中。

当选择线性空间时，Unity 会把输入纹理设置为 sRGB 模式，在这种模式下，硬件在对纹理进行采样时会自动将其转换 到线性空间中；并且， GPU 会在 Shader 写入颜色缓冲前自动进行伽马校正或是保持线性在后面 进行伽马校正，这取决当前的渲染配置

如果我们开启了 HDR 的话，渲染就会使用1个浮点精度的缓冲。这些缓冲有足够的精度不需要我们进行任何伽马校正，此时所有的混合和屏幕后处理都是在线性空间下进行的 当渲染完成要写入显示设备的后备缓冲区 back buffer 时，再进行最后的伽马校正。如果没有使用 HDR 那么 Unity 就会把缓冲设置 sRGB 格式 这种格式的缓冲就像 个普通的纹理，在写入缓冲前需要进行伽马校正，在 读取缓冲时需要再进行解码操作。如果 开启了混合（像我 之前的那样） 在每次混合时 硬件会首先把之前颜色缓冲 中存储的颜色值转换回线性空间中，然后再与当前的颜色进行混合 完成后再进行伽马校正 最后 校正后的混合结果写入颜色缓冲中 这里要注意，透明通道是 不会参与伽马校正的。



**移动平台**无法使用线性空间，因此需要自己在shader中进行伽马校正。

对非线性输入纹理的校正：

```
float3 diffuseCol = pow (tex2D (diffTex, texCoord) , 2.2 ); 
```

对输出的校正：

```
fragColor.rgb = pow(fragColor. rgb, 1.0/2.2); 
return fra gColor; 
```

