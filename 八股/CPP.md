## C++相关八股

C++的内容比较杂 主要围绕智能指针、多态这些东西讲

#### 智能指针（t0）

[C++11 智能指针【详解+实现】【面试常考】_智能指针的底层实现-CSDN博客](https://blog.csdn.net/qq_39384184/article/details/123853862)

#### 多态（t0）

[C++彻底搞定面试--多态篇，博主呕心沥血之作，万字解析，弄透多态_c++面试突破-CSDN博客](https://blog.csdn.net/m0_64361907/article/details/127288041)

[C++ 多态详解及常见面试题 - Duikerdd - 博客园 (cnblogs.com)](https://www.cnblogs.com/Duikerdd/p/11761124.html)

#### 右值（t0）

右值引用的主要优势在于支持移动语义和完美转发。移动语义允许我们直接接管某些类型的临时对象（右值）的资源，而无需进行昂贵的深拷贝操作。这可以大大提高处理大型对象（如大型数组或容器）的效率。完美转发则允许函数模板将其参数“完美地”转发给其他函数，这对于编写高效的泛型代码非常有用。

[【C++】—— 如何跟面试官讲述什么是右值引用_c++语法面试谈一谈右值引用。如何回答-CSDN博客](https://blog.csdn.net/chenxiyuehh/article/details/93665922)

衍生：`push_back` 和 `emplace_back`

#### C++编译过程（t1.5）

预处理Preprocessing--编译Compilation--汇编Assemble--链接Linking

- 预处理PreProcessing：换头文件 换宏定义 条件定义#ifdef #endif（通常用来避免重复编译）
- 编译：生成汇编代码.s文件，产生符号表（函数名，变量名）
- 汇编：生成机器码.o文件（可重定向文件）
- 链接：将多个.o文件相应的段合并建立映射关系，合并符号表进行符号解析，符号解析完成后给符号分配虚拟地址；将虚拟地址和符号表定义的符号一一对应，生成可执行文件

#### x86内存空间（t1.5）

文本段（Text Segment）：也被称为代码段，包含了程序的可执行代码。这个段具有执行权限。
数据段（Data Segment）：包含了初始化的全局变量和静态变量。
BSS段：包含了未初始化的全局变量和静态变量。
堆（Heap）：用于动态内存分配，如new操作符分配的内存。
栈（Stack）：包含了局部变量和函数调用的信息。

#### 面向对象的三个基本特征（t1.5）

- 封装(encapsulation)：即信息隐蔽。它是指在确定系统的某一部分内容时，应考虑到其它部分的信息及联系都在这一部分的内部进行，外部各部分之间的信息联系应尽可能的少。 `public` `protected` `private`
- 继承：让某个类型的对象获得另一个类型的对象的属性和方法。继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。
- 多态：C++的函数重载、模板（静态多态）和虚函数继承（动态多态）

#### new和malloc（t1）

1、 new/delete是C++关键字，需要编译器支持。malloc/free是库函数，需要头文件支持；

2、 使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸。

3、 new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。

4、 new内存分配失败时，会抛出bad_alloc异常。malloc分配内存失败时返回NULL。

5、 new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后**调用类型的构造函数，初始化成员变量，最后返回自定义类型指针**。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。

6、new是封装了malloc，直接free不会报错，但是这只是释放内存，而不会析构对象。

##### new和delete的实现

1、 new简单类型直接调用`operator new`分配内存；对于复杂结构，先调用`operator new`分配内存，然后在分配的内存上调用构造函数；

对于简单类型，`new[]`计算好大小后调用`operator new`；对于复杂数据结构，`new[]`先调用o`perator new[]`分配内存，然后在p的前四个字节写入数组大小n，然后调用n次构造函数

① new表达式调用名为`operator new(operator new[])`函数，分配足够大的、原始的、未命名的内存空间；

② 编译器运行相应的构造函数以构造这些对象，并为其传入初始值；

③ 对象被分配了空间并构造完成，返回一个指向该对象的指针。

2、 delete简单数据类型默认只是调用`free`函数；复杂数据类型先调用析构函数再调用`operator delete`；针对简单类型，`delete`和`delete[]`等同。假设指针`p`指向`new[]`分配的内存。因为要4字节存储数组大小，实际分配的内存地址为`[p-4]`，系统记录的也是这个地址。`delete[]`实际释放的就是`p-4`指向的内存。而`delete`会直接释放`p`指向的内存，这个内存根本没有被系统记录，所以会崩溃。

3、 需要在 `new []` 一个对象数组时，需要保存数组的维度，C++ 的做法是在分配数组空间时多分配了 4 个字节的大小，专门保存数组的大小，在 `delete []` 时就可以取出这个保存的数，就知道了需要调用析构函数多少次了。

##### 三种new

1. **plain new** 这是最常见的new 操作符，用于在堆上分配内存并调用对象的构造函数。如果内存分配失败，它会抛出`std::bad_alloc`异常。
2. **nothrow new** 这是一种特殊的new操作符，它不会在内存分配失败时抛出异常，而是返回一个空指针。这对于需要手动检查内存分配是否成功的情况非常有用。
3. **placement new** 这是一种更特殊的new作符，它允许你在已经分配的内存上构造一个对象。这对于需要在特定位置创建对象的高级用途非常有用。

这三种`new`操作符都有对应的`delete`操作符来释放内存和销毁对象。但是，请注意，对于`placement new`，你需要手动调用对象的析构函数，因为`delete`操作符无法正确地释放由`placement new`分配的内存。

**malloc、realloc、calloc：**

1. malloc是一个C语言中的函数，用于在堆上分配指定大小的内存。它接受一个参数，即要分配的字节数，并返回一个指向新分配的内存的指针。例如：

   ```c
   int* p = (int*)malloc(sizeof(int) * 10);  // 分配10个int
   ```

2. realloc也是一个C语言中的函数，用于改变已分配内存的大小。它接受两个参数，第一个是指向已分配内存的指针，第二个是新的内存大小（以字节为单位）。如果新的大小大于原来的大小，那么原来的内存将被扩展，新的空间将被初始化为垃圾值。如果新的大小小于原来的大小，那么原来的内存将被缩小，多余的空间将被释放。例如：

   ```c
   int* p = (int*)malloc(sizeof(int) * 10);  // 分配10个int的空间
   p = (int*)realloc(p, sizeof(int) * 20);  // 扩展到20个int的空间
   ```

3. calloc是另一个C语言中的函数，用于在堆上分配指定数量和大小的内存，并将其初始化为零。它接受两个参数，第一个是要分配的元素的数量，第二个是每个元素的大小（以字节为单位）。例如：

   ```c
   int* p = (int*)calloc(10, sizeof(int));  // 分配10个int的空间，并初始化为0
   ```

   这三个函数都有对应的`free`函数来释放内存。请注意，当你使用这些函数时，你需要检查它们是否成功返回了一个非空指针。如果内存分配失败，这些函数会返回一个空指针。

#### inline（t2.5）

[C++ | inline 内联函数是什么意思？【面试题】宏优缺点？详细讲解_inline修饰-CSDN博客](https://blog.csdn.net/2301_78131481/article/details/135831334?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~Ctr-2-135831334-blog-120569781.235^v43^pc_blog_bottom_relevance_base8&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~Ctr-2-135831334-blog-120569781.235^v43^pc_blog_bottom_relevance_base8&utm_relevant_index=5)

#### lambda（t2.5）

Lambda表达式，也被称为匿名函数，是一种定义轻量级函数的方式。Lambda表达式的形式通常如下：

```
捕获列表 mutable(可选) 异常属性 -> 返回类型 {
    // 函数体
}
```

例如，auto sum =  { return x + y; }; 是一个接受两个参数并返回它们之和的Lambda表达式。
**闭包**：在C++中，闭包是指由Lambda表达式创建的对象。每个Lambda表达式都会生成一个唯一的未命名的非联合类类型，我们通常称之为闭包类型。闭包类型的对象通常被称为闭包。闭包可以捕获它所在作用域中的变量，这些变量在Lambda表达式的函数体内可以直接使用。 在C++中，Lambda表达式的捕获列表部分就是用来定义闭包如何从创建它的作用域中捕获变量。例如，x { return x + y; } 就创建了一个闭包，它捕获了变量x。

[C++面试 C++11 新特性之 lambda_c++lamada面试题-CSDN博客](https://blog.csdn.net/qq_23225317/article/details/79774228)

#### 静态链接和动态链接（t2）

（网易会问）

##### lib和dll

- 静态库扩展名lib，链接器在将所有目标文件集链接到一起的过程中，会为所有当前未解决的符号构建一张“未解决符号表”。当所有显示指定的目标文件都处理完毕时，链接器将到“库”中去寻找“未解决符号表”中剩余的符号。如果未解决的符号在库里其中一个目标文件中定义，那么这个文件将加入链接过程，这跟用户通过命令行显示指定所需目标文件的效果是一样的，然后链接器继续工作直至结束。

  总的来说，静态链接就是在链接阶段把.o文件中所依赖的静态库链接到一起，最终生成的可执行文件当中包含lib中的函数，类等等

- 相对应的，动态链接所对应的库叫做动态链接库(Dynamic Linkable Library，缩写为DLL)。

  对于像 C 标准库这类常用库而言，如果用静态库来实现存在一个明显的缺点，即所有可执行程序对同一段代码都有一份拷贝。如果每个可执行文件中都存有一份如 printf, fopen 这类常用函数的拷贝，那将占用相当大的一部分硬盘空间，这完全没有必要。所以我们使用动态链接的方法来进行优化。

  它是这样进行链接的，当链接器发现某个符号的定义在DLL中，那么它不会把这个符号的定义加入到最终生成的可执行文件中，而是将该符号与其对应的库名称记录下来（保存在可执行文件中）。当程序开始运行时，操作系统会及时地将剩余的链接工作做完以保证程序的正常运行。在 main 函数开始之前，有一个小型的链接器（链接器隶属于系统）将负责检查贴过标签的内容，并完成链接的最后一个步骤：导入库里的代码，并将所有符号都关联在一起。在系统的管理下，应用程序与相应的DLL之间建立链接关系。当要执行所调用DLL中的函数时，根据链接产生的重定位信息，系统才转去执行DLL中相应的函数代码。一般情况下，如果一个应用程序使用了动态链接库，Win32系统保证内存中只有DLL的一份复制品。

- 动态链接库的优点：（1）更加节省内存；（2）DLL文件与EXE文件独立，只要输出接口不变，更换DLL文件不会对EXE文件造成任何影响，因而极大地提高了可维护性和可扩展性。

  动态链接库的缺点： 使用动态链接库的应用程序不是自完备的，它依赖的DLL模块也要存在，如果使用载入时动态链接，程序启动时发现DLL不存在，系统将终止程序并给出错误信息。

  静态链接库的优点： (1) 代码装载速度快，执行速度略比动态链接库快

  静态链接库的缺点： 使用静态链接生成的可执行文件体积较大，包含相同的公共代码，造成浪费。

##### 可执行文件如何确认动态链接：

一个可执行文件知道哪些动态链接库需要通过它的二进制文件格式，例如ELF（在Unix、Linux系统中）或PE（在Windows系统中）。这些文件格式中包含了一些特殊的段，用于存储动态链接信息。在ELF格式中，.dynamic段包含了一系列的动态链接信息，其中就包括需要的动态链接库列表。每个库都由一个名为DT_NEEDED的条目表示，该条目指向库的名称。

当操作系统加载一个可执行文件时，动态链接器（在Unix和Linux系统中通常是ld.so或ld-linux.so）会读取.dynamic段，找到所有DT_NEEDED条目，然后加载相应的库。动态链接器还负责解析库中的符号，将它们链接到可执行文件中的引用。

[【面经笔记】lib dll区别_dll面经-CSDN博客](https://blog.csdn.net/xiaxzhou/article/details/75578502)

#### 链接属性（t2）

在C/C++中，一个符号（变量或函数名）的链接属性是由它的定义和声明的方式决定的。以下是一些基本的规则：

1. **外部链接（External Linkage）**：如果一个符号在全局范围内定义（不在任何函数内部），并且没有使用`static`关键字，那么它就有外部链接属性。这意味着这个符号在其他文件中是可见的，只要通过`extern`关键字声明就可以使用。
2. **内部链接（Internal Linkage）**：如果一个符号在全局范围内定义，并且使用了`static`关键字，那么它就有内部链接属性。这意味着这个符号只在定义它的文件中可见。
3. **无链接（No Linkage）**：如果一个符号在函数内部定义，或者在类中定义，那么它就有无链接属性。这意味着这个符号只在定义它的函数或类中可见。

以下是一些影响链接属性的关键字：

- `static`：在全局范围内使用`static`可以使符号具有内部链接属性。
- `extern`：在全局范围内使用`extern`可以声明一个具有外部链接属性的符号。
- **const**：在C++中，全局`const`变量默认具有内部链接属性，除非显式地使用`extern`关键字声明。
- **inline**：在C++中，`inline`函数具有内部链接属性，除非它们是类的成员函数（这种情况下，它们具有外部链接属性）。
- **constexpr**：在C++中，`constexpr`变量和函数都具有内部链接属性。
- **名称空间（Namespace）**：名称空间本身没有链接属性，但是名称空间中的符号的链接属性遵循上述规则。

链接属性对编译器优化有一定的影响。编译器在进行优化时，需要考虑符号的可见性和生命周期，这两个因素都与链接属性有关。

1. **内联函数（Inline Functions）**：具有内部链接属性的函数，特别是被声明为`inline`的函数，可以被编译器内联。这意味着编译器可以直接在函数调用处插入函数体的代码，从而避免函数调用的开销。但是，这种优化只能在函数定义对编译器可见的情况下进行，也就是说，函数必须在同一个编译单元中被调用和定义。
2. **常量传播（Constant Propagation）**：如果一个具有内部链接属性的`const`变量在编译时已知其值，那么编译器可以在优化时将这个变量的值直接替换到使用它的表达式中，这种优化称为常量传播。
3. **死代码消除（Dead Code Elimination）**：如果一个具有内部链接属性的函数或变量在其定义的编译单元中没有被使用，那么编译器可以安全地删除这些未使用的符号，因为它们不会在其他编译单元中被引用。
4. **全局变量优化（Global Variable Optimization）**：具有内部链接属性的全局变量只能在一个编译单元中被访问，这使得编译器可以更好地进行全局变量的优化，例如将全局变量放入寄存器中，或者进行全局变量的生命周期分析。

#### C++的实现线程安全的单例（t3）

[C++11实现线程安全的单例模式(使用std::call_once)_c++11 线程安全-CSDN博客](https://blog.csdn.net/u011726005/article/details/82356538)

#### VS中的PDB（t5）

程序数据库 ( *.pdb*) 文件（也称为符号文件）将项目源代码中的标识符和语句映射到已编译应用中的相应标识符和说明。 这些映射文件将调试器链接到源代码，以进行调试。.pdb 文件保存调试和项目状态信息，使用这些信息可以对应用的调试配置进行增量链接。 在调试时，Visual Studio 调试器使用 .pdb 文件来确定两项关键信息：

- 要在 Visual Studio IDE 中显示的源文件名和行号。
- 在应用中停止的断点位置。