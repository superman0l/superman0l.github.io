## 操作系统和计组的八股

这玩意问多少纯取决面试官 体感上平均问的不多

#### 物理内存 虚拟内存

##### 虚拟内存和物理内存、虚拟内存存在哪里

- **物理内存**，也被称为主存，是计算机中实际存在的内存，包括RAM（随机存取存储器）和ROM（只读存储器）。物理内存是有限的，它的大小取决于计算机硬件的配置。**虚拟内存**是一种内存管理技术，它使得应用程序认为它们拥有连续的可用内存，而实际上，它们的物理内存可能是分散的，甚至部分内存可能已经被交换到硬盘上。虚拟内存的主要目的是为了让每个程序都认为自己独占了全部的物理内存，从而简化内存管理。
- 虚拟内存主要存在硬盘上，当系统物理内存不足时，操作系统将一部分数据从物理内存中移出，存储到硬盘的某个区域，当数据再次被需要时再从硬盘都回物理内存。

页置换算法：FIFO、OPT(最佳置换 放屁用)、LRU最近最少使用、二次机会引用位、LFU/MFU 用的最多和用的最少置换

[【面试八股总结】内存页面置换算法-CSDN博客](https://blog.csdn.net/rabbit_qi/article/details/139385132)

##### 虚拟地址如何转换物理地址

提取虚拟页号和页内偏移量：从进程的虚拟地址中提取虚拟页号和页内偏移量。
查找虚拟页号对应的物理页框号：在MMU的页表中查找虚拟页号对应的物理页框号。如果虚拟页号没有对应的物理页框号，就会触发缺页异常，需要操作系统将相应的页从磁盘中读入到内存中。
组合成物理地址：将物理页框号和页内偏移量组合成物理地址。
返回物理地址：将物理地址返回给进程，进程就可以访问对应的物理存储地址。

[『面试问答』：什么是虚拟内存？为什么要有虚拟内存？_牛客网 (nowcoder.com)](https://www.nowcoder.com/discuss/558779313537986560)

#### TLB快表

TLB（Translation Lookaside Buffer），也被称为快表，是一种硬件缓存，用于加速虚拟地址到物理地址的转换过程。当CPU需要访问内存中的数据时，它会使用虚拟地址来寻址，然后通过TLB来将该虚拟地址转换为对应的物理地址，最终访问到真正的数据。

TLB的作用在于减少每次地址转换时需要访问页表的次数，从而提高内存访问的效率。TLB中存放了之前已经进行过地址转换的查询结果。这样，当同样的虚拟地址需要进行地址转换的时候，可以直接在 TLB 里面查询结果，而不需要多次访问内存来完成一次转换。

TLB中的项由两部分组成：标识和数据。标识中存放的是虚地址的一部分，而数据部分中存放物理页号、存储保护信息以及其他一些辅助信息。虚地址与TLB中项的映射方式有三种：全关联方式、直接映射方式、分组关联方式

[面试官：不同进程对应相同的虚拟地址，在 TLB 是如何区分的？-腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/2008239)

#### 进程线程（t0）

**进程管理：PCB**

进程控制块（PCB），**操作系统为每个进程都维护一个PCB**，用来保存与该进程有关的各种状态信息。进程可以抽象理解为就是一个PCB，**PCB是进程存在的唯一标志**，操作系统用PCB来描述进程的基本情况以及运行变化的过程，进程的任何状态变化都会通过PCB来体现。**PCB包含进程状态的重要信息**，包括程序计数器、堆栈指针、内存分配状况、所打开文件的状态、账号和调度信息，以及其它在进程由运行态转换到就绪态或阻塞态时必须保存的信息，从而保证该进程随后能再次启动，

**中断向量**：中断向量是指中断服务程序的入口地址

**PCB存储信息**：

- **进程标识信息 **本进程的标识，本进程的父进程标识，用户标识等；
- **处理机状态信息保护区** 保存进程的运行现场信息，包括用户可见寄存器（用户使用数据），控制和状态寄存器（程序计数器，程序状态字），栈指针（调用，中断，返回）；
- **进程控制信息** 包括调度和状态信息，进程间通信信息（通信相关的标识），进程资源，存储管理信息

**进程生命周期管理**：创建 运行 阻塞 唤醒 结束。**挂起**：利用系统资源，把一个进程从内存转到外存。进程在挂起状态时，意味着进程没有占用内存空间，处在挂起状态的进程映射在磁盘上。

**进程调度**：FCFS、SJF(最短)、优先级调度、响应度优先(响应比Rp = (等待时间+要求服务时间)/要求服务时间)、时间片轮转、多级反馈队列(多个队列不同时间片，优先级越高时间片越小，没处理完进入下一个队列，队列按优先级高到低FIFO处理)

**为什么使用线程**：多进程方式进行并发编程，进程间的通信也很复杂，并且维护进程的系统开销较大：创建进程时分配资源建立PCB，撤销进程时回收资源撤销PCB，进程切换时保存当前进程的状态信息。所以为了使并发编程的开销尽量小，所以引入多线程编程，可以并发执行也可以共享相同的地址空间。

线程优点：并发执行、共享地址空间和文件资源、比进程轻量级

线程缺点：一旦一个线程崩溃，会导致其所属进程的所有线程崩溃；由于各个线程共享相同的地址空间，那么读写数据可能会导致竞争关系，因此对同一块数据的读写需要采取某些同步机制来避免线程不安全问题。

- 区别

  1、因为进程拥有独立的堆栈空间和数据段，所以每当启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这对于多进程来说十分“奢侈”，系统开销比较大，而线程不一样，线程拥有独立的堆栈空间，但是共享数据段，它们彼此之间使用相同的地址空间，共享大部分数据，比进程更节俭，开销比较小，切换速度也比进程快，效率高，但是正由于进程之间独立的特点，使得进程安全性比较高，也因为进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。一个线程死掉就等于整个进程死掉。
  2、体现在通信机制上面，正因为进程之间互不干扰，相互独立，进程的通信机制****相对很复杂，譬如管道，信号，消息队列，共享内存，套接字等通信机制，而线程由于共享数据段所以通信机制很方便。
  3、体现在CPU系统上面，线程使得CPU系统更加有效，因为操作系统会保证当线程数不大于CPU数目时，不同的线程运行于不同的CPU上。
  4、体现在程序结构上，举一个简明易懂的列子：当我们使用进程的时候，我们不自主的使用if else嵌套来判断pid，使得程序结构繁琐，但是当我们使用线程的时候，基本上可以甩掉它，当然程序内部执行功能单元需要使用的时候还是要使用，所以线程对程序结构的改善有很大帮助。

  [线程和进程的区别（面试必备）_进程和线程的区别-CSDN博客](https://blog.csdn.net/qinian8/article/details/100779193)

- 进程线程间通

  [进程和线程的总结（两者区别、通讯方式、死锁）_进程和线程通信的区别-CSDN博客](https://blog.csdn.net/qq_44685867/article/details/114637221?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~Ctr-1-114637221-blog-139507709.235^v43^pc_blog_bottom_relevance_base8&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~Ctr-1-114637221-blog-139507709.235^v43^pc_blog_bottom_relevance_base8)

- **上下文切换**：操作系统停止当前运行进程（从运行状态改变成其它状态）并且调度其它进程（就绪态转变成运行状态）。操作系统必须在切换之前存储许多部分的进程上下文，必须能够在之后恢复他们，所以进程不能显示它曾经被暂停过，同时切换上下文这个过程必须快速，因为上下文切换操作是非常频繁的。那**上下文指的是什么呢**？指的是任务所有共享资源的**工作现场**，每一个共享资源都有一个工作现场，包括用于处理函数调用、局部变量分配以及工作现场保护的栈顶指针，和用于指令执行等功能的各种寄存器。

#### 用户态和内核态

系统态(也称为管态或核心态)，操作系统在系统态运行——运行操作系统程序
用户态(也称为目态)，应用程序只能在用户态运行——运行用户程序

处于用户态执行时，进程所能访问的内存空间和对象受到限制，其所占有的处理机是可被抢占的；而处于核心态执行中的进程，则能访问所有的内存空间和对象，且所占用的处理机是不允许被抢占的。

用户态切换到内核态的唯一途径——>中断/异常/陷入，内核态切换到用户态的途径——>设置程序状态字

#### 多路IO复用

是一种允许单个进程监视多个文件描述符以查看是否准备好进行I/O的技术。对于同时处理多个连接（例如，在网络服务器中）非常有用。在没有多路I/O复用的情况下，你可能需要为每个连接创建一个线程，并且每个线程都会阻塞在I/O操作上。这种方法的缺点是线程的开销可能很大，特别是当连接数很多时。

多路I/O复用通过允许单个线程在多个文件描述符上等待I/O操作准备就绪，解决了这个问题。当某个文件描述符准备好进行I/O操作时，操作系统会通知应用程序，然后应用程序可以对该文件描述符进行读写操作。

多路I/O复用的主要优点是它可以使用较少的线程来处理多个连接，从而减少了线程切换的开销。此外，由于在任何时候只有少数线程在运行，所以它还可以减少内存使用。

在Unix和Linux系统中，常用的多路I/O复用技术有select、poll和epoll。在Windows系统中，常用的多路I/O复用技术有select和IOCP（I/O完成端口）。

1. **select**：`select`是最早的I/O多路复用解决方案，它可以同时监视多个文件描述符（包括socket）。当某个文件描述符就绪（读就绪，写就绪，或者有异常）时，`select`就会返回。但`select`有一些限制和缺点：
   - 文件描述符的数量受限于FD_SETSIZE的大小，默认是1024。
   - 每次调用`select`，都需要传入所有的文件描述符，即使只有少数的文件描述符就绪，也需要遍历所有的文件描述符，这在文件描述符数量很大时会导致效率问题。
2. **poll**：`poll`和`select`类似，但是没有最大文件描述符数量的限制。`poll`使用一个`pollfd`的数组来存储要监视的文件描述符，这解决了`select`的文件描述符数量限制的问题。但是，`poll`仍然有一个效率问题，那就是当文件描述符数量很大，而就绪的文件描述符数量很小的时候，`poll`仍然需要遍历所有的文件描述符。
3. **epoll**：`epoll`是Linux特有的I/O多路复用解决方案，它没有最大文件描述符数量的限制，而且它只会返回就绪的文件描述符，不需要遍历所有的文件描述符，因此，`epoll`在处理大量文件描述符时，效率比`select`和`poll`高。`epoll`使用一种称为事件驱动的方式，只关心I/O就绪的文件描述符，因此，即使文件描述符数量很大，也不会影响`epoll`的效率。

​     [面试必备：对 select，poll，epoll 的详细解析_poll和select和epoll的作用-CSDN博客](https://blog.csdn.net/Geffin/article/details/105364662)

#### 忙等和挂起

**忙等（Busy Waiting）**：

- 优点：**简单**：实现忙等的代码通常比较简单，只需要一个循环来检查条件是否满足。**响应快**：如果等待的时间非常短，忙等可以立即响应条件的改变，因为它一直在检查条件。
- 缺点：**CPU资源浪费**：忙等会占用大量的CPU资源，因为它在等待期间一直在运行，即使条件并未满足。

**挂起（Blocking or Sleeping）**：

- 优点：**节省CPU资源**：当线程被挂起时，它不会消耗CPU资源。这使得CPU可以被其他需要运行的线程使用。**适用于长时间等待**：如果等待的时间可能很长，那么挂起是更好的选择，因为它不会浪费CPU资源。
- 缺点：**响应慢**：当条件满足时，挂起的线程需要被操作系统唤醒，这可能需要一些时间。因此，如果等待的时间非常短，挂起可能会导致不必要的延迟。**实现复杂**：实现挂起通常需要操作系统的支持，因此代码可能会比忙等更复杂。

#### 大小端

**小端（Little Endian）**：最低有效字节（LSB）存储在最低的地址，最高有效字节（MSB）存储在最高的地址。例如，一个四字节的整数0x12345678在内存中的存储方式（从低地址到高地址）为：78 56 34 12。

**大端（Big Endian）**：最高有效字节（MSB）存储在最低的地址，最低有效字节（LSB）存储在最高的地址。例如，一个四字节的整数0x12345678在内存中的存储方式（从低地址到高地址）为：12 34 56 78。

**小端的优势**：

- 对于加法运算和乘法运算，小端模式可以立即开始运算，而不需要等待所有的字节都被处理。
- 在处理器中，小端模式可以更快地检测到上溢和下溢。

**大端的优势**：

- 大端模式在网络通信（尤其是TCP/IP协议）中被广泛使用，因为人类通常从高位开始读数，大端模式更符合人类的阅读习惯。
- 在某些排序算法中，大端模式可以更快地比较两个字符串的大小。

#### buddy和slab

[linux - 面试官：你谈谈对物理内存和虚拟内存的理解，一文彻底搞懂 - 柠檬橙的专栏 - SegmentFault 思否](https://segmentfault.com/a/1190000022506020)

#### cache

**为什么要使用Cache**：我们都知道，CPU主频的提升会带动系统性能的改善，但系统性能的提高不仅取决于CPU，还与系统架构、指令结构、信息在各个部件之间的传送速度及存储部件的存取速度等因素有关，特别是CPU与主存之间的存取速度有关。若CPU工作速度特别高，但内存存取速度相对较低，则造成CPU等待，降低处理速度，一定程度上是在浪费CPU的能力。由以上两点，我们得知要想进一步改善计算机系统的性能，就应该减少CPU与内存之间的速度差异，所以我们可以在慢速的DRAM和快速的CPU之间插入一至多级的速度较快、容量较小的SRAM起到缓冲作用；使CPU既可以较快地存取主存中的数据，又不使系统成本上升过高，这就是Cache法。

**程序访问的局部性原理**：程序访问的局部性原理是什么？程序访问的局部性：在一个较短的时间间隔内，由程序产生的地址往往集中在存储器逻辑地址空间的很小范围内，这种对局部范围的存储器地址频繁访问，而对此范围以外的地址则访问甚少的一种现象。程序访问的局部性原理和Cache的关系：利用程序访问的局部性原理，可以在主存和CPU的通用寄存器之间设置Cache，把正在执行的指令地址附近的一部分指令或数据从主存调入这个寄存器，供CPU在一段时间内使用，从而提高CPU访问存储系统的速度。当程序继续执行时，程序访问的局部性原理也不断变化，新的数据将不断地从主存调入Cache中替换掉原有的数据。
**Cache的工作原理**：主存地址的划分为了方便比较和快速查找，Cache和主存都被分成了若干大小相同的块，每块又包含若干个字。显然Cache分块数远远小于主存的分块数。上述地址中不同字段的作用分别如下：主存块地址：是CPU访问主存单元地址按块大小划分后得到的一个地址，用于标识CPU所访问的主存单元所在的主存块号。通过该地址可以缩小查找的范围。块内偏移地址：又称块内地址，表示CPU所要访问的单元在某块的偏移值，找到数据所在的块后，根据该值可以定位CPU要访问的具体单元。索引：即作为Cache存储体的地址指示器，指出CPU访问Cache存储体的范围，如指定Cache的某一行或某几行。标记：标记也是对主存块地址进一步划分后得到的更细粒度的地址，作为判断CPU所要访问的内容是否在Cache中的依据。
**Cache的地址映射及变换方法**：地址映射是指把主存地址空间映射到Cache的地址空间，即把存放在主存中的程序或数据按照某种规则装入Cache，并建立两者之间地址的对应关系。地址变换是指在程序运行时，根据地址映像函数把主存地址变换成Cache地址。地址映射与变换方法有关，不同的地址映射方法具有不同的地址变换方法。三种地址映射方法: （1）全相联映射 （2）直接映射 （3）组相联映射。
**Cache的三种替换算法**：1.先进先出（FIFO） 2.近期最少使用（LRU）和最不经常使用（LFU） 3.随机法。