##### C#的多继承：

在C#中，类不能直接实现多继承，即一个类不能同时继承多个类。但是，C#提供了其他方式来实现多继承的效果

接口实现：在C#中，一个类可以实现多个接口

```c#
public interface IInterface1
{
    void Method1();
}

public interface IInterface2
{
    void Method2();
}

public class MyClass : IInterface1, IInterface2
{
    public void Method1()
    {
        // 实现 IInterface1 的 Method1
    }

    public void Method2()
    {
        // 实现 IInterface2 的 Method2
    }
}

```

接口扩展方法：另一种实现多继承的方式是通过接口的扩展方法1。例如，你可以定义一个空接口和一个扩展该接口的静态类。

```
public interface IFlyable
{
}

public static class FlyableExtensions
{
    public static void Fly(this IFlyable flyable)
    {
        // 实现飞行的代码
    }
}

public class Bird : IFlyable
{
    // Bird 类可以使用 Fly 方法
}
```

C#的gc：

https://www.cnblogs.com/caden/p/17273006.html

垃圾回收的算法有有多种，在.Net中采用了一种叫做"**标记与清除(Mark-Sweep)**"算法，该算法分两个本领：

- "**标记**"本领——垃圾的识别：从应用程序的root出发，利用相互引用关系，遍历其在Heap上动态分配的所有对象，没有被引用的对象不被标记，即成为垃圾；存活的对象被标记，即维护成了一张"根-对象可达图"。其实，CLR会把对象关系看做"树图"，这样会加快遍历对象的速度。.Net中利用栈来完成检测并标记对象引用，在不断的入栈与出栈中完成检测：先在树图中选择一个需要检测的对象，将该对象的所有引用压栈，如此反复直到栈变空为止。栈变空意味着已经遍历了这个局部根能够到达的所有对象。树图节点范围包括局部变量、寄存器、静态变量，这些元素都要重复这个操作。一旦完成，便逐个对象地检查内存，没有标记的对象变成了垃圾。
- "**清除**"本领——回收内存：启用压缩（Compact）算法，对内存中存活的对象进行移动，修改它们的指针，使之在内存中连续，这样空闲的内存也就连续了，这就解决了内存碎片问题，当再次为新对象分配内存时，CLR不必在充满碎片的内存中寻找适合新对象的内存空间，所以分配速度会大大提高。但是大对象（large object heap）除外，GC不会移动一个内存中巨无霸，因为它知道现在的CPU不便宜。通常，大对象具有很长的生存期，当一个大对象在.NET托管堆中产生时，它被分配在堆的一个特殊部分中，移动大对象所带来的开销超过了整理这部分堆所能提高的性能。

GC算法的设计考虑到了4个因素：

- 对于较大内存的对象，频繁的进行GC将耗费大量的资源，成本很高且效果较差
- 大量新创建的对象生命周期都较短，老对象的生命周期都较长
- 小部分的进行GC比大块的进行GC效率更高，消耗更少
- 新创建的对象在内存分配上多为连续，且关联程度较强，关联度较强有利于CPU Cache命中。

基于此，按照寿命长短，托管堆被分为了三个年龄层，分别是Generation 0，Generation 1， Generation 2。垃圾收集器在第 0 代存储新对象。在应用程序生命周期早期创建的在收集过程中幸存下来的对象被提升并存储在第 1 代和第 2 代中。因为压缩托管堆的一部分比压缩整个堆要快，因此该方案允许垃圾收集器在特定代中释放内存，而不是在每次执行收集时释放整个托管堆的内存

##### 野指针

- 使用未初始化的指针：如果定义了一个指针变量但没有对其进行初始化，这个指针就可能成为野指针
- 指针所指对象已消亡
- 指针释放后未置空

两矩形判断碰撞？

对于矩形的位置的长宽进行考虑是否有交集



**push_back()和emplace_back()都是用于在容器（如vector）尾部添加元素的方法，但它们在效率和使用方式上有一些区别**

push_back()方法：

push_back()方法有两个版本：void push_back(const T& value)和void push_back(T&& value)。
当使用push_back()向容器尾部添加元素时，首先会创建这个元素，然后再将这个元素拷贝或移动到容器中
如果是拷贝的话，事后会自行销毁先前创建的这个元素
push_back()只支持一个构造参数，如果需要传入多个构造参数，则需要手动构造一个临时对象
emplace_back()方法：

emplace_back()方法的声明为：template< class... Args > void emplace_back( Args&&... args )
从C++14开始，emplace_back()的返回值从void改为了返回对插入元素的引用
emplace_back()可以接受多个构造参数
当使用emplace_back()向容器尾部添加元素时，会直接在容器尾部创建这个元素，省去了拷贝或移动元素的过程



