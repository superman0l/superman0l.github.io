##### 介绍一下CPP多态

多态：

- 静态多态
  - 函数重载
  - 泛型编程
- 动态多态
  - 虚函数

两种类型多态：静态多态（编译时多态） 动态多态（运行时多态）

静态多态是通过函数重载和运算符重载来实现的，编译器在编译时根据函数或运算符的参数类型来选择调用哪个函数或运算符。静态多态性在编译时确定函数的调用，不涉及运行多态绑定

动态多态是通过虚函数和继承来实现，允许在基类中定义虚函数，派生类重写虚函数来实现特定行为。运行时根据对象实际类型决定调用哪个参数实现动态绑定。动态多态性能够在运行时根据对象的类型调用正确的函数

##### 介绍一下智能指针

- `std::unique_ptr` 
  - 独占语义 开销小 速度快
  - deleter是智能指针的一部分 可以定制来释放资源
- `std::shared_ptr`
  - 共享语义
  - 性能：原生指针的两倍大小、引用计数的内存必须被动态分配、引用计数的递增或递减必须是原子的
  - deleter不是智能指针的一部分 可以定制释放资源
  - 避免从原生指针类型变量创建`std::shared_ptr`
- `std::weak_ptr`
  - 通常由一个`std::shared_ptr`来创建
  - 检查是否过期 `if(wpw.expired())`
- 优先使用std::make_unique 和 std::make_shared 而不是直接new
- 不适合使用make:
  - 需要自定义deleter
  - 需要传递大括号initializer

`std::unique_ptr` :

- std::unique_ptr 提供对动态分配对象的独占所有权，即同一时间只有一个std::unique_ptr 实例可以拥有指向特定对象的指针
- std::unique_ptr 被销毁时，所拥有的对象也会被销毁，从而避免了内存泄漏
- 不支持拷贝构造和赋值操作 但可以通过移动语义(move semantics)进行所有权的转移

std::shared_ptr:

- std::shared_ptr 允许多个指针共享对同一对象的所有权，它使用引用计数来跟踪有多少个std::shared_ptr实例指向相同的对象
- 当最后一个指向对象的std::shared_ptr被销毁时，对象才会被销毁
- std::shared_ptr使用引用计数来管理内存，因此可能存在循环引用导致内存泄露的问题，可以使用std::weak_ptr解决

##### 了解智能指针源码吗？

##### 介绍一下C#装箱拆箱

在C#中，装箱(boxing) 和 拆箱(unboxing) 时将值类型转换为引用类型以及将引用类型转换为值类型的过程。当需要将值类型存储到堆上（引用类型）中时，就需要进行装箱操作；当需要将引用类型转换为值类型时就需要拆箱操作

装箱(boxing):

装箱时将值类型转换为对象类型的过程，例如将int类型转换为object类型

在装箱时CLR会在堆上创建一个新的对象并将值类型的值复制到该对象中

装箱会导致性能问题，涉及到内存分配和复制操作。在大量装箱操作中会导致大量GC(Garbage Collection)压力和内存碎片

拆箱(unboxing)：

拆箱是将对象类型转换为值类型的过程：object->int

拆箱时CLR会检查对象是否包含与指定值类型相匹配的数据，并将其复制到值类型的变量中。

如果对象不包含相匹配的数据将抛出InvalidCastException异常



**GC压力**：GC是垃圾收集(Garbage Collection)的简称，它是.NET运行时环境用来自动管理内存的机制。当你创建一个对象，.NET运行时就会在堆上为它分配内存。当这个对象不再被使用时，GC就会释放它占用的内存。但是，GC的运行是需要消耗系统资源的。如果有大量的装箱操作，就会频繁地创建和销毁对象，这就给GC带来了压力，可能会导致GC更频繁地运行，从而影响应用程序的性能。

**内存碎片**：当对象被创建和销毁时，会在内存中留下空洞，这些空洞就像碎片一样散布在内存中，我们称之为内存碎片。内存碎片会影响内存的使用效率。比如，如果你需要分配一个大对象，但是内存中只有一些小的、不连续的空洞，那么这个大对象就无法被分配。即使总的可用内存是足够的，但是由于内存碎片的存在，仍然可能导致内存分配失败。大量的装箱操作会加速内存碎片的产生，因为每一个装箱操作都会在堆上创建一个新的对象。



##### 怎么让UDP实现可靠传输？ 

UDP是一种无连接的传输协议不提供可靠性保证。可以通过在应用层实现一些机制增强UDP可靠传输

应用层重传：在发送端和接收端实现自定义重传机制，当检测到丢包或坏包则让发送端重传

确认和超时：引入确认机制，接收方返回确认信息告知成功收到，发送方计时器超时重传

##### 知道线程安全吗？加锁的后果是什么？

线程安全是值多线程环境下程序的执行结果与单线程环境的执行结果相同。如果程序在多线程环境下能正确处理并发访问问题则线程安全

加锁是常见实现线程安全的方式。当多个线程需要同时访问共享资源时使用锁确保按照一定顺序访问避免数据竞争

##### 介绍一下umg

Unread Motion Graphics UE用于创建UI和交互的工具，提供可视化界面编辑器实现UI包括菜单HUD游戏页面等

##### 介绍UE反射机制

引擎或游戏代码能够在运行时检查、加载、创建和操作类、对象、函数等数据结构的能力。

主要包括：

- 类型信息存储：编译过程中UE会收集各种类、结构体、函数等类型信息，并将其存储为元数据，包括类的名称、成员变量、函数签名等信息
- 动态类型创建：运行时UE会根据类的名称动态创建对象实例，而不需要提前知道类的确切类型，为实现工厂模式、插件系统等提供便利
- 反射属性访问：通过反射机制可以在运行时动态获取和设置类的成员变量、调用类的方法
- 蓝图支持：蓝图可以在运行时修改类的属性、调用类的方法，这些修改会在实际的CPP类上反映
- 序列化/反序列化：支持将对象状态序列化为数据流以便存储或传输，也支持从数据流反序列化出对象实例

##### 怎么确定点在三角形内

算法：有n个有序列表，如何组合成一个有序列表



一些补充：

UMG（Unreal Motion Graphics UI Designer）是虚幻引擎4（UE4）中的一个可视化UI创作工具1。它基于Slate框架实现，Slate框架同时也是UE4编辑器界面使用的框架2。UMG可以用来创建UI元素，如游戏中的HUD、菜单或您希望呈现给用户的其他界面相关图形1。

在UI相关的工作中，主要会用到以下几种文件3：

Blueprint （ User Inteface-Blueprint） 也就是常说的UMG，是我们常用的UI工程文件
Font （字体资源拖入Content Browser自动生成）字体文件
Texture (PNG资源拖进来可以自动生成) 图片资源文件
Material 材质文件，可用于UI材质或者mesh材质
UMG的核心是控件，这些控件是一系列预先制作的函数，可用于构建界面（如按钮、复选框、滑块、进度条等）

UMG有很多优势，例如实时预览、3DUI、蓝图系统等

在虚幻引擎4（UE4）中，SWidget和UWidget是UMG（Unreal Motion Graphics）系统的两个重要组成部分。

SWidget：SWidget是Slate的抽象基类，遵循Slate编程写法，是链式编程1。SWidget主要用于底层的Slate GUI框架，它需要在代码中手动一行行敲出来，运行效率高，但是无法断点调试也不利于维护1。
UWidget：UWidget是向UObjects公开的所有已包装Slate控件的基类，是Widget Blueprint里面的可视化编辑控件，方便开发设计直接编辑UI和实现功能1。UWidget解决了SWidget编辑困难的问题，在运行时会转换为SWidget1。
在UMG中，UWidget和SWidget的关系是紧密的。UMG是基于Slate的，而Slate就是由SWidget组成的。在UMG中，我们看到和操作的都是UWidget，但实际上，UWidget是对SWidget的封装1。例如，当我们在UMG编辑器中拖动控件，对其设置属性时，实际上是在对SWidget进行修改1。

总的来说，SWidget是UMG的底层基础，而UWidget则是我们在开发过程中主要接触和操作的部分。通过UWidget封装SWidget，UMG提供了一个更高级和便利的UI设计工具



UE的垃圾回收机制主要基于标记-清除算法2。标记-清除算法包括两个阶段：标记和清除12：

标记阶段：遍历所有对象，根据某种规则，标记其是否需要清除12。
清除阶段：遍历所有对象，清除标记了的对象，回收内存12。
UE的垃圾回收机制有以下特点12：

自动化：UE对所有的UObject对象提供了自动垃圾回收机制，当达到GC条件时（内存不足，到达GC时间间隔，切换场景强制GC），会通过扫描系统中所有的UObject是否存活，来清理那些不需要UObject对象，释放其内存空间2。
可定制：UE允许开发者手动触发垃圾回收，可以通过调用GEngine->ForceGarbageCollection(bool bForcePurge)接口，来让UE进行一次完整的垃圾回收2。
高效：UE的垃圾回收机制使用了集群特性，可以把它当作一个有着共同生命周期的UObjects集合，把它当作一个整体，该整体的可达性由这个集群的Cluster Root是否可达来决定2。

标记阶段：在这个阶段，Collector从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的 Header 中记录为可达对象12。这个过程可以递归进行，直到遍历完所有活动对象为止12。
清除阶段：在这个阶段，Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其 Header 中没有标记为可达对象，则将其回收12。这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放覆盖原有的位置12。

在虚幻引擎4（UE4）的垃圾回收（Garbage Collection，简称GC）机制中，Cluster是一组UObject，它们类型不必相同，其中有一个UObject可以作为Cluster的根，称为ClusterRootObject1。GC时，会把Cluster作为一个整体来处理，其中的UObject和ClusterRootObject被引用状态相同1。

ClusterRootObject在程序中的表示为FUObjectCluster这个类。主要属性包括1：

RootIndex：RootOBject在GUObjectArray中的下标
Objects：Cluster中包含的Uobjects
ReferencedClusters：这个Cluster引用的其他Cluster
MutableObjects：这些UObject不在Cluster中，与Cluster关系比较松散，不会随着Cluster一起被标记为不可达，但Cluster被引用到时也会跟着一起被标记为被引用到。
ClusterRoot可以位于Objects数组，也可以位于MutableObjects数组

一次垃圾回收分为两个阶段。在标记阶段是一次性标记完的，但是在清除阶段可以分帧进行，以降低对游戏性能的影响。



构造函数：在C++中，构造函数不能是虚函数123。这是因为虚函数依赖于对象的虚函数表（vtable），而在构造函数被调用时，对象还未完全构造，vtable可能还未被正确设置。因此，构造函数不能被声明为虚函数。
静态函数：在C++中，静态函数也不能是虚函数456。静态成员函数是类级别的，不依赖于类的实例，因此没有this指针。而虚函数的实现依赖于this指针来访问虚函数表（vtable）。因此，静态函数不能被声明为虚函数。
模板函数：在C++中，模板函数不能是虚函数7891011。这是因为虚函数的调用需要在编译时确定，而模板函数的实例化发生在编译期间，编译器无法预知所有可能的实例化类型，因此无法为所有可能的模板函数实例生成虚函数表（vtable）。



内存对齐主要有两个原因：

平台原因（移植原因）：并非所有的硬件平台都能访问任意地址上的任意数据。某些硬件平台只能在某些地址处取某些特定类型的数据，否则会抛出硬件异常12345。
性能原因：数据结构（尤其是栈）应该尽可能地在自然边界上对齐。原因在于，对于访问未对齐的内存，处理器需要进行两次内存访问；而对齐的内存访问仅需要一次访问12345。