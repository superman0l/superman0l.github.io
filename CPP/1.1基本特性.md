####  指针与引用的区别是什么？

- 存在形式：指针是一个变量，有自己的内存空间；而引用只是一个变量的别名。因此在使用sizeof获取指针和引用的内存大小时，指针的大小是4(32bit系统下)，而引用则返回被引用对象的内存大小。
- 初始化时：指针可以被初始化为NULL，而引用必须被初始化关联一个已有对象。
- 初始化后：指针可以被修改指向其他变量，而引用不可以改变所引用的对象。
- 使用操作上：指针需要被解引用才可以进行变量操作，指针对于++、--、+=、-=操作符具有特殊的意义；而对引用的操作就是直接修改所引用的变量的值。
- 其他：指针可以有多级指针（**ptr），而引用不存在多级引用。

#### const修饰变量：

```cpp
const int x = 0; // const修饰变量x为常量
int *ptr = (int*)&x;
(*ptr) = 1;
cout<<x<<endl;  // 输出0
cout<<*ptr<<endl;  // 输出1
```

这段代码可以编译通过，但运行时我们会发现输出指针ptr指向的地址空间值是1，但输出变量x的值仍是0。这与编译器的优化有关，编译器发现定义变量x与输出变量x的代码之间没有对变量x进行修改，那么在输出x的值时候编译器会从寄存器中读取上次读变量x的值，而不是真正的去变量x所在的内存地址去取值。

为了避免上述问题，我们可以使用volatile去修饰变量x，来告知编译器这个变量值是多变的，在取变量值时编译器会从该变量的内存地址取，从而避免由于编译器优化产生的取值错误。

```cpp
volatile const int x = 0; // const修饰变量x为常量
int *ptr = (int*)&x;
(*ptr) = 1;
cout<<x<<endl;  // 输出1
```

#### const修饰类成员函数

const修饰类成员函数作用是限制成员函数不能修改成员变量的值，但const不能与static共同修饰类的成员函数，因为static修饰的类成员函数在调用时不通过this指针不能实例化，const成员函数必须关联到具体的实例。

```cpp
class student {
    public:
        student(std::string name) : m_name(name) {}
        std::string getName() const{// 在这一成员函数中不允许修改成员变量的值
            return m_name;
        }
    private:
        std::string m_name;
};
```

#### static修饰局部变量

static修饰局部变量为静态局部变量，静态变量的内存位置则从栈区移动到了全局(静态)存储区,局部变量的生命周期得到延续(全局静态存储区在进程运行结束时自动释放)。且无论函数调用多少次，static修饰的静态局部变量只执行初始化一次。

static修饰符的另一个作用是限制变量可见性，被static修饰的静态变量只能在**本文件**中被访问，其他文件即便使用extern外部声明也不可以访问该变量。这一特性可以避免在不同的文件中定义同名函数和同名变量产生的命名冲突。

static可为程序提高效率，因为static修饰的变量存储在内存的全局(静态)存储区，在全局(静态)存储区所有内存字节默认值是0x00，即变量值默认都是0。因此，当程序在初始化一个矩阵值全为0时，不需要进行2层循环去遍历每个数组成员，只需将数据声明为static即可。

#### static修饰类成员

被static修饰的成员函数和成员变量是属于类的静态资源，类的所有实例共享，不能通过this指针访问静态资源。

- static修饰类的成员变量，则该成员变量是类的静态变量，进程内存空间中只有一个副本。由于静态成员变量存储在全局静态存储区，与类的对象存储区域无关，因此不能在构造类的对象时(构造函数)中初始化静态成员变量，只能在类的外部进行初始化静态资源。

- static修饰类的成员函数，则该成员函数被类的所有实例共享，静态成员函数调用过程没有this指针参与，因此静态成员函数调用具有以下的限制： (1)不能在静态成员函数中使用类的非静态成员变量 (2)不能在静态成员函数中调用非静态成员函数 (3)不能把静态成员函数声明为虚函数

### const_cast 常量类型转换

```cpp
const_cast<type> (expression);
```

const_cast的两个作用：

- **const_cast用于去掉变量的const属性**：由于const修饰变量为常量，且const变量不能直接赋值给非const的变量，因此代码语义需要修改const变量的值或想要将const变量的值赋值给非const变量时，必须使用const_cast去掉const属性。
- **const_cast也可用于为变量加const属性**，但使用较少，因为非const类型变量可直接赋值给const类型变量。

> 注意：const_cast只能对**指针**或**引用**添加或移除const

### static_cast 静态类型转换

- 基本类型之间的转换：例如int与float、int与char、int与enum等，需要程序员保证安全性。
- 空指针与其他目标类型指针之间互相转换：例如void**与*int*。
- 基类与派生类的指针或引用之间转换(不推荐)：上行转换(派生类指针/引用转基类类型)安全、下行转换(基类指针/引用转换成派生类类型)**危险**，缺少动态类型检查。

> 为什么基类指/引用转换为派生类指针/引用是不安全的？ 
>
> 在基类中有int型成员a，派生类中有int型成员b和继承自基类的成员a。当我们定义了一个基类指针ptr指向派生类对象时，由于ptr只能解释基类的内存长度，因此当ptr指向基类对象且ptr被强制转换为派生类指针，使用ptr访问派生类自定义的成员时会发生无法预料的结果。

### dynamic_cast 动态类型转换

dynamic_cast用于基类指针/引用向派生类指针/引用进行安全的转换(安全的向下转型)；向上转型本身就是安全的，使用static_cast可提高效率。

使用dynamic_cast进行向下转型有两种情况：

- 当基类指针指向的对象是派生类对象时，该基类指针转换为派生类指针是安全的，因为该指针指向的是派生类的对象，无论我们通过指针访问基类的成员还是派生类的成员都是安全的。dynamic_cast转换成功时返回值是转换后的指针。
- 当基类指针指向的是基类对象时，该基类指针转换为派生类指针是危险的。dynamic_cast转换的基类必须有[虚函数](https://blog.nowcoder.net/n/fb6cfda4c27c448c9e20ca90c46344a0)，dynamic_cast在转换时依赖虚指针进行运行时检查，若本次下行转型的基类指针指向的对象是基类对象，则转换失败返回NULL。
- 同样的，对于基类类型的引用在下行转型时，若该引用是派生类对象的引用转换是安全的，dynamic_cast返回值是转换后的引用；若该引用是基类对象的引用转换是危险的，dynamic_cast抛出bad_cast异常，因此程序应在转换时进行必要的异常捕获与处理。

### reinterpret_cast 重新解释转换

```
reinterpret_cast<type> (expression);
```

- 从一个类型的指针/引用转换到另一个类型的指针/引用
- 指针类型与足够大的整形之间相互转换
- 从某个函数的指针转换到另一个函数的指针
- 从一个对象的指针转换到另一个不同类型的对象指针

```cpp
int funcA() {return 0;}
int main()
{
    typedef void(*VoidFuncPtr)();  //定义指向返回值void无参函数的指针
    VoidFuncPtr ptr = &funcA; // 编译不通过，定义funcA的返回类型int；
    // 但我们可以使用reinterpret_cast对funcA的值进行重新解释
    VoidFuncPtr ptr = reinterpret_cast<VoidFuncPtr>(&funcA);
    // 此时，ptr仍然指向funcA函数的首地址，但是funcA函数的返回值被重新解释为void
    return 0;
}
```

### C++函数调用的过程？

- 1.压栈：程序启动时，main函数栈帧生成，依次将main函数返回地址入栈和函数参数从右至左压栈。

- 2.跳转执行：跳转到main函数执行，在main函数中定义了两个int变量x和y，压入栈中,ESP向下拓展。

- 3.调动子函数：main函数中调用func函数，func函数栈帧生成，main函数的EBP栈底指针入栈，当前的ESP赋值给EBP；

- 4.压栈：依次将func函数返回地址入栈和函数参数从右至左压栈,ESP向下拓展。

- 5.跳转执行：跳转到func函数执行，在func函数中定义了一个局部变量ret压入栈中,ESP向下拓展。

- 6.恢复：func函数调用完毕，局部变量ret、形参列表、返回地址依次出栈，ESP随之收缩，EBP恢复到main函数的栈底值。

- 7.恢复：main函数调用完毕，局部变量、形参列表、返回值依次出栈。程序结束，图略。

### 内联函数

内联函数在编译时，编译器会将函数的代码副本放置在内联函数被调用处进行代码展开。

定义内联函数的方式：在函数声明前加inline关键字。

- 优点：内联函数在函数调用处进行代码展开，取消了函数的参数压栈等调用过程。当函数体比较小或函数实现机制比较简单的时候, 内联该函数可以令目标代码更加高效。
- 缺点：若内联函数函数体复杂或代码量较多，可能使目标代码量陡增，从而降低效率。递归函数，或者函数中有switch或循环表达式时不应声明为内联函数，虚函数也不会被编译器正常内联。

### 内联函数与宏定义区别？

- 宏定义是在预处理过程中进行宏替换，内联函数是编译器控制进行代码展开。
- 内联函数在编译器会像普通函数一样具有参数类型推导和安全检查，而宏只是宏替换。
- 内联函数可以访问对象的私有成员函数，例如定义类的成员存取函数。