## 封装

**封装的意义可总结为：使代码模块化，对外部隐藏实现细节。**

### 类的构造函数

- 初始化列表用于初始化成员变量列表，在构造函数后使用冒号':'和成员变量列表进行初始化可以避免1次构造函数调用。相对于构造函数，初始化列表是真正的初始化动作，构造函数则是赋值，初始化列表工作在构造函数之前。类中const成员变量、引用类型、没有默认构造函数的其他类类型必须在初始化列表中进行初始化动作。

```
class student{
public:
    student(std::string schoolName) : m_SchoolName(schoolName), m_ClassName("student") {}
private:
    std::string m_SchoolName;
    const std::string m_ClassName;  // const成员需要在初始化列表中进行初始化
};
```

- 拷贝构造函数 拷贝构造函数是较为特殊的构造函数，一般用于复制其他对象的成员变量来构造新的对象。如果类中没有定义拷贝构造函数，则编译器会定义默认的拷贝构造函数。

> 注意：若类中定义了指针并动态申请了内存，则该类必须显示定义拷贝构造函数以表明指针如何拷贝。否则，若类未定义拷贝构造函数，编译器会自动实现默认的拷贝构造函数，默认的拷贝构造函数中对指针成员的拷贝是**浅拷贝**，那么当拷贝构造的对象或被拷贝的对象析构时，二者的成员指针申请的内存资源会一起被释放。

### this指针与成员函数调用

C++引入了this自引用指针，当使用类实例化对象时，编译器生成this指针指向实例化对象的内存地址，this指针的值为对象的起始地址。 

注意：一个对象的this指针并不是对象本身的一部分，不会影响该对象sizeof()的结果。例如，对一个空类的对象执行sizeof()，得到其内存大小是1，而不是指针的内存大小。占用内存大小为1的原因是每个实例对象在内存中都应该有独一无二的内存地址，空类实例化对象时被编译器插进去一个char，使得这个类的不同对象在内存中都有有独一无二的内存地址。

#### 请介绍面向对象封装的概念、意义和实现机制。

- 概念：类是为了描述某个事物在解决问题中的属性和行为，把客观的事物抽象成类这个行为称为封装。
- 意义：封装使代码模块化，对外部隐藏实现细节
- 实现机制：封装将成员变量和成员函数聚集在类中，通过访问限定符限制类成员在类内部和外部的访问权限。类的成员函数有两个特殊形式，即类的构造函数和析构函数。构造函数在类的对象实例化时被调用，一般用于赋值成员变量；析构函数在类的对象生命周期结束时被调用，一般用于释放该对象申请的资源。

#### 多继承及对象内存布局

- C++支持多继承，即派生类可以继承于多个基类，派生类拥有所有基类的特性。多继承的语法与普通继承类似，在继承列表中使用逗号分割继承方式和基类名：

```cpp
class base1{
public:
    int x;
}；
class base2{
public:
    int y;
}；
class derive : public base1, public base2{
public:
    int z;
};
```

#### 菱形继承及其带来的影响

若派生类继承于多个基类，这些基类又有共同的基类，就会形成菱形继承的分布。

```cpp
class base{
public:
    int x;
    int y;
};
class base1 : public base{
public:
    int ba1;
};
class base2 : public base{
public:
    int ba2;
};
class derive : public base1, public base2{
public:
    int de;
};
```

可以发现在派生类derive中存在两份基类base的成员，尽管依然可以使用域(::)操作符来区分derive中的成员x、y，但这对于derive来说无疑是内存空间的浪费。

#### 虚继承及虚基类的特性

- 为了解决菱形继承带来的内存和计算资源的浪费，C++提供了虚继承机制，使得派生类在间接继承共同的基类时只保留一份间接基类的成员。虚继承的语法为：

```cpp
class derive : virtual public base; // 使用virtual关键字进行虚继承
```

此时，类base是类derive的虚基类。

- 虚基类由它最后的派生类进行初始化，最后的派生类对象在构造时，不仅要调用直接基类的构造函数，还要调用虚基类的构造函数。由于虚基类只被最后的派生类进行初始化，不被其他中间的派生类初始化，因此避免了虚基类的成员被重复初始化。
- 在最后的派生类中访问虚基类的成员，也不需要使用域(::)来指明来自于哪个直接基类，因为最后的派生类中只有一份虚基类成员。

#### 虚继承的实现机制

虚继承的实现是通过虚表指针(virtual base table pointer, vbtp)和虚基类(virtual base table, vbt)表实现的，每个虚继承得到的派生类对象内部都有一个虚表指针(4字节)和一个虚基类表(不占对象的内存空间)。最后的派生类在实例化对象时对虚基类进行了一次初始化，虚基类表中记录了派生类的对象与虚基类对象的偏移地址，派生类对象通过偏移地址访问虚基类对象的成员。

虚基类的派生类被当做基类继承时，虚表指针也会被继承。

#### 什么是菱形继承？菱形继承有什么影响？如何避免菱形继承产生的影响？

- 菱形继承：若派生类继承于多个基类，这些基类又继承于共同的基类，就会形成菱形继承的分布。
- 菱形继承带来的影响：在菱形继承中最后的派生类会包含共同基类的多份成员副本，不仅会产生访问共同基类成员的歧义，而且会带来内存空间的浪费。
- 使用虚继承避免菱形继承产生的成员访问歧义和内存浪费。虚继承的派生类对象会产生一个虚基类指针，指向虚基类表。虚基类表记录了派生类相对于基类成员的内存偏移，派生类在访问基类成员时，根据虚基类表的内存偏移访问基类成员，因此基类成员只有一份实例，派生类对象的内存空间没有基类成员的副本。

## 多态

在C++中，多态按照编译器的实现机制可分为静态多态和动态多态，静态多态是编译器在编译期间就可以确定的接口重用，表现形式为：函数重载和模板；动态多态是在运行过程中编译器根据对象动态绑定的实际类型调用相应的函数，表现形式为：虚函数。

构成动态多态需要两个必备条件

- 1.调用函数必须通过对象的指针或者对象的引用。
- 2.被调用的函数必须是虚函数，且派生类进行了虚函数的覆盖。

```cpp
class person{
public:
    virtual void printAge(){
        cout<<"年龄-未知"<<endl;
    }
};
class adult : public person{
public:
    virtual void printAge(){
        cout<<"年龄>=18岁"<<endl;
    }
};
class young : public person{
public:
    virtual void printAge(){
        cout<<"年龄<18岁"<<endl;
    }
};
```

纯虚函数：在基类中没有定义，但要求任何盖基类的派生类都要对纯虚函数定义自己的实现方法。声明了纯虚函数的类被称为虚基类，虚基类不允许实例化对象。

定义纯虚函数的方法为在虚函数的原型后加`=0`：

```cpp
class Animal{
public:
    virtual void Eat() = 0;
};
```

### 虚析构函数

通常情况下，虚函数在覆盖时不允许修改该函数的函数名、参数类型和返回值。但是有一个例外：基类中的析构函数如果是虚函数，那么派生类的析构函数尽管与基类的析构函数名不相同，编译器也会通过特殊的机制认为派生类的虚析构函数覆盖了基类的虚析构函数。

事实上基类的析构函数被声明为虚函数是被推荐的行为。一般情况下，析构函数的用于释放对象申请的资源，例如指针成员动态申请的内存需要去主动delete释放掉。当我们使用基类指针去指向派生类对象并delete该基类指针时，会发生两种情况：(1)若基类和派生类的析构函数不是虚函数，那么delete基类指针只会调用基类的析构函数，不会调用派生类的析构函数，此时若该对象成员中有指针类型且动态申请了内存，那么就不会在派生类的析构函数中被释放，从而造成了内存泄漏。(2)若基类和派生类的析构函数为虚函数，那么delete基类指针时会先调用派生类的析构函数、再调用基类的析构函数，因此安全的释放了对象资源。

```cpp
class person{
public:
    virtual ~person() {}  // 虚析构函数
};
class student : public person{
public:
    student() {
        p = new char[256];
    }
    virtual ~student() {
        delete p;
    }  
    char *p;
}
int main(){
    person* ptr = new student();  // 基类指针指向派生类对象
    delete ptr;  // 析构时先调用派生类的析构函数，释放动态申请的资源，避免了内存泄漏 
}
```

### 虚函数的实现机制

虚函数的实现机制与虚继承具有相似之处：声明了虚函数的对象会生成一个虚指针(Virtual table pointer, vtp)，它指向虚函数表(Virtual Table，虚表)，虚表中存储了该类声明的所有虚函数的入口地址。当该类被当做基类继承时，派生类同样会继承基类的虚表，且派生类覆盖继承得到的虚函数时，会在派生类的虚表中的相应位置将虚函数替换。

通常声明了虚函数的类实例化的对象的内存空间前4个字节为虚指针，在调用对象的虚函数时，通过该对象的虚指针访问虚表中函数的入口地址进行函数调用。声明了虚函数的类被当做基类继承时，派生类会继承基类的虚表。当派生类覆盖了基类的虚函数时，覆盖的新虚函数会在虚表中替换已有的函数入口地址，在实际调用时若调用对象为派生类对象，从而在实际调用时可以根据调用对象中的虚指针找到其指向的虚表中的正确函数入口。

### 函数及运算符重载

C++支持函数与运算符制定多个定义，分别称为函数重载和运算符重载。

```cpp
class Merchandise{
public:
    Merchandise(int price) {
        price_ = price; // 初始化
    }
    // 重载 +运算符，使得+运算符可以实现两个商品的价格相加
    Merchandise operator+ (const Merchandise& obj) {
        Merchandise tmp;
        tmp.price_ = this->price_ + obj.price_;
        return tmp;
    }
    int price_;
};
```

#### 请介绍C++中的多态

多态是指多个同名的函数执行不同二点操作，使得同一个函数名具有不同的行为，其目的是实现接口的重用。 在C++中，多态按照编译器的实现机制可分为静态多态和动态多态；

- 静态多态是编译器在编译期间就可以确定的接口重用，表现形式为：函数重载和模板，在调用函数时编译系统根据实参的值进行类型推导情况确定最适配的函数重载实现。
- 动态多态是在运行过程中编译器根据动态绑定的实际类型调用相应的函数，表现形式为：虚函数。基类中声明的虚函数被继承到派生类中，派生类对继承得到的虚函数可以重新实现，被称为虚函数覆盖(override)。当我们通过指针或引用调用虚函数时，编译器会根据动态绑定判断实际调用对象的函数实现。声明了虚函数的类会产生一个虚表，虚表中记录了类的所有虚函数入口地址。当发生继承时，虚表会继承到派生类中，若派生类覆盖了某个虚函数，则派生类的虚表会替换覆盖的虚函数。每个声明了虚函数的类的对象都有一个虚指针指向虚表，当虚函数被调用时，编译器根据实际调用对象的虚指针访问类的虚表，从而实现匹配的函数调用。